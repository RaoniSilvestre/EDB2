\section{Heap}

Nessa seção, são explicadas as estruturas de MinHeap e MaxHeap. Ambas foram implementadas em
Rust, devido as atividades da primeira unidade, pois as ordenações da primeira únidade foram feitas
em Rust. Primeiramente explicaremos a Max Heap e após isso, mais resumidamente devido a semelhança, 
a Min Heap.

\subsection{Max Heap}

A Max Heap é uma espécie de árvore, que é comumente implementada como lista. A única 
condição para que uma árvore/lista seja considerada uma Max Heap, é que para todo nó, 
seu filhos devem ter prioridade menor que o pai.

Desse modo, nota-se que o maior elemento da Max Heap sempre será a raiz dela
(ou o H[0], no caso da lista).

\subsubsection{Estrutura}

Na implementação da Max Heap, criamos um WrapperType(uma classe), para encapsular o
funcionamento da Max Heap:

\vspace{3mm}

\begin{lstlisting}
pub struct MaxHeap<T> {
    data: Vec<T>,
}
\end{lstlisting}

\vspace{3mm}

\subsubsection{Alteração de prioridade}

Para realizar a alteração de prioridade na heap(o tira casaco, bota casaco dela),
é preciso implementar as funções de subir e descer na heap. Elas servem para manter a
principal propriedade da (max)heap: cada nó tem prioridade maior que seus filhos.

\vspace{3mm}

\textbf{1. Função subir} 

\vspace{3mm}

Para a função de subir(bubble\_up), a implementação é simples.
Pegamos a heap(\&mut self) e a posição que ira subir como argumentos.
Devido as propriedades da heap, sabemos que o pai da $self[i]$ está na
posição $i/2$, e dessa forma verificamos se o filho tem prioridade maior que o pai.
Se for o caso, as posições do filho e do pai são trocadas,
e então chama-se a função recursivamente na posição do pai.


\begin{lstlisting}
pub fn bubble_up(&mut self, mut index: usize) {
    while index > 0 {
        let parent = (index - 1) / 2;
        if self[index] <= self[parent] {
            break;
        }
        self.swap(index, parent);
        index = parent;
    }
}
\end{lstlisting}

\vspace{3mm}

\textbf{2. Função subir} 

\vspace{3mm}

Para a função de descer, é um pouco mais complicado. Visto que cada item da heap terá 2 filhos,
é preciso levar em conta os dois, para decidir o que fazer no algoritmo.


Primeiramente, pegamos a quantidade de elementos na Heap e então fazemos uma iteração.

Para cada iteração, comparamos a prioridade do index atual com a prioridade de seus filhos,
caso algum dos filhos seja maior que o pai, realizamos o swap do pai com o filho, e
repetimos o processo.
Se nenhum dos filhos é maior que o pai, significa que o item desceu até a posição correta,
e paramos o loop.

\begin{lstlisting}
pub fn bubble_down(&mut self, mut index: usize) {
    let last_index = match self.len() {
        0 => 0,
        n => n - 1,
    };
    loop {
        let left_child = (2 * index) + 1;
        let right_child = (2 * index) + 2;
        let mut largest = index;
        if left_child <= last_index && self[left_child] > self[largest] {
            largest = left_child;
        }
        if right_child <= last_index && self[right_child] > self[largest] {
            largest = right_child;
        }
        if largest == index {
            break;
        }
        self.swap(index, largest);
        index = largest;
    }
}
\end{lstlisting}

\subsubsection{Inserção}
